---
title: 面试总结
categories:
- 面试总结
tags: 面试
date:
---

1.说下公司人员配比？

简单的说了下，被问到没有运维人员吗？愣了一下说都是自己来

2.CAP原则中，eureka实现了哪两个原则和ZK有什么不同？

Eureka保证的是AP(可用性和分区容错性)：Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。

自我保护机制：在15分钟内，如果超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：

	1、Eureka不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务

	2、Eureka任然能够提供服务注册和查询请求，但是暂时不会将注册的服务同步到其他节点上(即保证当前节点依然可用)

	3、当网络稳定时，当前实例新的注册信息才会被同步到其它节点上

Zookeeper保证CP（一致性和分区容错性）：在z k集群中，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，选举leader的时间太长，30~120秒，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪，而在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率发生的事，虽然服务最终能够恢复，但是长时间选举时间导致的注册长期不可用是不能容忍的。

3.Xxl-job你们怎么用的？部署了多少个，集群情况下调度同一个定时任务执行器会执行多次吗？

说了xxl-job内部有自己的集群可以手动配置，简要的说只部署了1个，因为它不是做高可用来使用的，主要起的就是一个定时调度的作用。

如果部署多个，调度同一个定时任务执行器不会执行多次，因为它是在自己内部的集群中的；调度的时候会指定对应的机器只会触发对应集群上的定时任务

4.分布式事务有用到吗？用在什么场景下？(over)

感觉这个真的必问的，没答上来。害，谁叫我们没遇到过呢

5.Mq如何保证消息的顺序消费？(over)

我用过activemq我就说下它的吧，其他的还没用过不太了解；activeMq通过高级特性consumer（独有消费者来实现），messageGroups消息组来实现；具体的实现原理我不太记得了，下来我再去看一下；

6.spring的事务特性？

原子性 （atomicity）:强调事务的不可分割.

一致性 （consistency）:事务的执行的前后数据的完整性保持一致.

隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰

持久性（durability） :事务一旦结束,数据就持久到数据库

7.Spring的事务隔离机制

DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.

未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生

已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生

可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生.

串行化的 （serializable） :避免以上所有读问题.

Mysql 默认:可重复读

Oracle 默认:读已提交

8.说说什么是脏读，幻读，不可重复读

脏读 :一个事务读到了另一个事务的未提交的数据

幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.

不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.

9.springMvc的执行流程 （太长了记得不是太清楚，醉了）

s p ri n g Mv c是一种设计 思想，将Model数据层，View视图层，Controller控制层分离解耦，从而简化了开发，使得结构更加清晰明了！也便于了各开发人员之间的配合！	

   (1）用户发送请求至前端控制器DispatcherServlet；

（2） 前端控制器收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；

（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给前端控制器；

（4）前端控制器 调用 HandlerAdapter处理器适配器；

（5）处理器适配器 经过适配调用 具体处理器(Handler，也叫后端控制器)；

（6）后端控制器执行完成返回ModelAndView；

（7）处理器适配器   将  后端控制器  执行结果ModelAndView返回给  前端控制器；

（8）前端控制器   将ModelAndView    传给ViewResolver视图解析器进行解析；

（9）ViewResolver  解析后返回具体View；

（10）DispatcherServlet  对View进行渲染视图（即将模型数据填充至视图中）

（11）DispatcherServlet  响应用户。

10.索引有哪些种类(答的不全)

普通索引：仅加速查询

唯一索引：加速查询 + 列值唯一（可以有null）

主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

全文索引：对文本的内容进行分词，进行搜索

11.为啥使用索引就能优化查询效率（over）

举个例子：没用索引前，查询相当于直接去磁盘读；使用索引后会先去索引表中读取所需地址的引用，通过对应的引用再去查找对应的数据效率上就快很多；索引是树机构（B-tree或B+tree），基于这种树结构可以使用二分查找法（O（log2n））；

12.mysql的存储引擎InnoDB和MyISAM 有啥区别（被问懵逼，具体可看下面各存储引擎的特点）

不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。

  功能    	MylSAM	MEMORY	InnoDB	Archive
  存储限制  	256TB 	RAM   	64TB  	None   
  支持事务  	No    	No    	Yes   	No     
  支持全文索引	Yes   	No    	No    	No     
  支持树索引 	Yes   	Yes   	Yes   	No     
  支持哈希索引	No    	Yes   	No    	No     
  支持数据缓存	No    	N/A   	Yes   	No     
  支持外键  	No    	No    	Yes   	No     

可以根据以下的原则来选择 MySQL 存储引擎：

- 如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。
- 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。
- 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。
- 如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。

提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。

InnoDB 是系统的默认引擎，支持可靠的事务处理。

使用下面的语句可以修改数据库临时的默认存储引擎

SET default_storage_engine=< 存储引擎名 >

13.看你简历上有些前端的技术，会一点前端是吧；那我问你js内置的对象有哪些？（再次over）

数据封装类对象：String，Boolean，Number，Array，和Object;

其他对象：Function，Arguments，Math，Date，RegExp，Error

14.synchronized 和lock的区别？

synchronized 可修饰方法，变量，类。是一个关键字，Lock本质是一个类；

对于少量代码的同步我们选择用synchronized,对于大量代码的同步我们用lock;另外，synchronized在同步代码执行完后会自动释放锁，而lock锁需要我们在finally中手动释放锁；

synchronized锁状态无法判断是，lock锁状态可以判断；它们都是可重入锁，但是synchronized 非公平的；lock锁是公平的（先到先得，非公平锁先到不一定先得）

synchronized 不可中断，就是后面线程要么拿到锁，要么一直阻塞

lock锁可中断（如果一个线程等待锁的时间太长了，有权利中断当前已经获取锁的线程的执行，也可以退出等待）

15.synchronized 的特性？

可重入性（同一个线程可以再次获得锁），不可中断性
